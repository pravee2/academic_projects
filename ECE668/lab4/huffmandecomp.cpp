/* 
Name: Varun Praveen
CUID: pravee2
Course: ECE-6680
Assignment #: 4
Description: This code implements a huffman decompression algorithm for compressed files generated by the huffmancodec.cpp file.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <math.h>

/**********************		Compare function for qsort   	****************************/
int compare_function(const void* a, const void* b)
{
	unsigned char *x = (unsigned char *)a;				
	unsigned char *y = (unsigned char *)b;
 	return *x - *y;

}
/* 	Compare function for sorting of frequencies 	*/
int compare_function_int(const void *a, const void* b)
{
	int *x = (int *)a;
	int *y = (int *)b;
	return *x - *y;

}
/* Tree nodes for huffman tree*/
struct node
{
	unsigned char val;
	int freq;
	struct node* left;
	struct node* right;
	unsigned char code;
};

typedef struct node Node;

/* 	sort function for tree nodes 	*/
bool sortCompare(struct node A, struct node B){	return A.freq>B.freq;}


Node* getleaf(Node *root, unsigned char sym)
{
	if(root!=NULL)
	{	
		if(root->val == sym)
			return root;
		else
		{
			getleaf(root->left,sym);
			getleaf(root->right,sym);
		}
	}
	else
		return NULL;
}

/* Get leaf where the symbol is present in the tree */
Node* getleaf_logic2(Node *root, unsigned char symbol)
{
	Node *temp;
	temp = (Node*)malloc(sizeof(Node));
	if(root==NULL)
		return NULL;
	else
	{	
		if(root->val == symbol)
			return root;
		else
		{
			temp = getleaf_logic2(root->left, symbol);
			if(temp==NULL)
				temp = getleaf_logic2(root->right, symbol);
			return temp;
		}
	}
}

/* Traversing binary tree to find the symbol and derive code for the symbol */
bool getCode(unsigned char symbol,int* size, int* &pattern, Node *root)
{
	bool code;
	if(root==NULL)
		return 0;
	else
	{
		if(root->val == symbol)
			return 1;
		else
		{
			(*size)++;
			pattern = (int*)realloc(pattern, (*size)*sizeof(int));			//reallocating size of the pattern depending on node location
			pattern[*size-1] =0;							//setting current but to 0 for left traversal
			code = getCode(symbol,size,pattern,root->left);				//traversing through left branch
			if(!code)
			{	
				pattern[*size-1] = 1;						//if left traversal fails updated final bit to 1
				code = getCode(symbol,size,pattern,root->right);		//check right branch		
			}
			if(!code)
				(*size)--;							//if code has not deen detected at all reduce pattern size by 1
			return code;								//return true if pattern is found else return FALSE

		}		
	}
				

}

/* Pre order printing of tree elements */
void elementPrint( Node *root ) 
{
	if(root!=NULL)
	{
		std::cout<< "Root Val: " << root->val << "\t" << "Root Frequency: " << root->freq << std::endl;
		elementPrint(root->left);
		elementPrint(root->right);
	}
} 

/* Counting number of nodes in the tree*/
int NodeCount(Node *root)
{
	if(root == NULL)
		return 0;
	else
	{
		int count=1;
		count += NodeCount(root->left);
		count += NodeCount(root->right);	
		return count;				

	}
}



int main( int argc, char *argv[])
{


FILE 				*fpt_in, *fpt_out, *fpt_inter;
int 				i,j,k;
unsigned char 			*data_in;
int 				 *data_stream;
unsigned char			dictionary_count;
int 				symbolCount;
unsigned char			*dictionary;
int				*frequency, *frequency_sorted;
unsigned char 			byte;
int				fileSize;
int 				treeCount=0;

std::vector<Node>dict;
dict.clear();
/* Check for usage errors */
if(argc!=3)
{
	printf("Invalid Usage: huffmandecomp [input_filename] [output_filename]\n");
	exit(0);
}

/* Check for file name errors */
if(fopen(argv[1],"rb")==NULL)
{
	printf("Invalid input filename: %s\n", argv[1]);
	exit(0);
}

fpt_in = fopen(argv[1],"rb");
fpt_out = fopen(argv[2],"wb");

/* computin filesize of the file to be compressed */
fileSize = 0;
while(fread(&byte,1,1,fpt_in)!=0)
	fileSize++;

printf("File size is: %d\n",fileSize);
fseek(fpt_in, 0, SEEK_SET);


int readcount;
i = fread(&dictionary_count,sizeof(dictionary_count),1,fpt_in);
std::cout<<"Dictionary count: " << (int) dictionary_count << std::endl;
readcount = j;

/* allocating and reconstructing dictionary from compressed file */
dictionary = (unsigned char*)malloc(dictionary_count*sizeof(unsigned char));
frequency = (int*)malloc(dictionary_count*sizeof(unsigned int));

j = fread(dictionary, sizeof(unsigned char), dictionary_count, fpt_in);				//reading dictionary elements values from header
k = fread(frequency, sizeof(int), dictionary_count, fpt_in);					//reading corresponding frequencies from header

/* Setting total count of data read till this point as 
readcount = 1 * sizeof(unsigned char) + count * sizeof(unsigned char) + count * sizeof(int) */

readcount = i + j + k * 4;									//computing remaining size after header for variable bit code
//std::cout << "Read count:" << readcount << std::endl;
int streamcount = fileSize - readcount;
//std::cout << "Stream count : "<< streamcount << std::endl;
data_in = (unsigned char*)malloc((fileSize - readcount)*sizeof(unsigned char));
fread(data_in,sizeof(unsigned char),streamcount,fpt_in);
//free(data_in);						//freeing sorted data post frequency and dictionary entry computation
data_stream = (int*)calloc((fileSize - readcount)*8,sizeof(int));
unsigned char c;
for(i=0;i<streamcount;i++)
{
	c = data_in[i];
	for(j=0;j<8;j++)
	{
		data_stream[i*8+(7-j)] = c%2;							//converting byte pattern to consecutive binary values for easy decompression
		c = c/2;
	}	
}

/* printing out equivalent binary data stream */
/*for(i=0;i<streamcount*8;i++)
	std::cout << data_stream[i] << "\t";

std::cout<<std::endl;
*/


Node temp;
/* Creating a vector of dictionary entries to be able to form a tree */
for(i=0;i<k;i++)
{
//	memset(&temp,0,sizeof(Node));
	temp.freq = frequency[i];
	temp.val = dictionary[i];
	temp.left = NULL;
	temp.right = NULL;
	dict.push_back(temp);	
//	printf("frequency sorted [%d] = %d\n",i, temp.freq);
}

//std::cout << "Dictionary size: " << dict.size() << std::endl;

//sort(dict.begin(),dict.end(), sortCompare);

//for(i=0; i< dict.size(); i++)
//	std::cout<< "Dictionary Element: " << dict[i].val <<"\t"<< dict[i].freq << std::endl;


Node *minimum, *lastmin;

//minimum = (Node*)malloc(1*sizeof(Node));
int iter = 1;
//lastmin = (Node*)malloc(1*sizeof(Node));



/* creating dictionary tree based on the header of the huffman compressed file */
while(dict.size()>1)
{
	
	minimum = (Node*)malloc(1*sizeof(Node));
	lastmin = (Node*)malloc(1*sizeof(Node));
//	memset(&temp,0,sizeof(Node));
	sort(dict.begin(), dict.end(), sortCompare);
	*minimum = dict[dict.size()-1];
	*lastmin = dict[dict.size()-2];
	dict.pop_back();
	dict.pop_back();
	temp.val = '\0';
	temp.freq = (minimum->freq) + (lastmin->freq);			//creating a parent node with frequency = sum of lowest frequencies
	temp.left = minimum;						//assigning left child
	temp.right = lastmin;						//assigning right chld
	dict.push_back(temp);						//pushing tree node to dictionary
	iter++;	
//	free(minimum);
//	free(lastmin);
}


Node *root = (Node*)malloc(1*sizeof(Node));
*root = dict[0];							//assigning root node of dictionary
Node *next, n2n;
//next = *(root->left);
//n2n = *(next.left);



/* computing code for each element in the dictionary */
bool codeDetect;
int *size;
int **pattern;
size = (int*)malloc(dictionary_count*sizeof(int));
pattern = (int**)malloc(dictionary_count*sizeof(int*));
unsigned int total_size = 0;

for(i=0; i<dictionary_count; i++)
{
	size[i] = 0;
	pattern[i] = NULL;
	codeDetect = getCode(dictionary[i], &size[i], pattern[i], root);	
	total_size += size[i]*frequency[i];				//gives the total size of the number of bits in file and number of padded bits to ignore
}



std::cout << total_size << std::endl;
int curr_bit;
unsigned char outcode;
Node *head, *curr;
head = (Node*)malloc(sizeof(Node));
curr = (Node*)malloc(sizeof(Node));
head = root;
curr = root;
i=0;
for(;i<total_size+1;)
{
	if(curr->left == NULL&& curr->right == NULL)			//implying that the traversal has reached a leaf node where the values are stored and there are no more child nodes
	{	
//		std::cout<<curr->val<<std::endl;
		outcode = curr->val;
		fwrite(&outcode,sizeof(unsigned char),1,fpt_out);	//fwrite code value to file
		curr = head;
	}
	else
	{
		curr_bit = data_stream[i];				//else check the data stream	
		if(curr_bit == 0)					
			curr = (curr->left);				//if current bit is 0 traverse left branch
		else
			curr = (curr->right);				//if current bit is 1 traverse right branch
		i++;
//		total_size = total_size - i;
	}
}

std::cout<< "Decompression concluded" << std::endl;


fclose(fpt_out);
fclose(fpt_in);
free(dictionary);
free(frequency);
//free(outstream);
free(data_stream);
free(root);
free(pattern);
free(size);
free(minimum);
free(lastmin);

return 0;

}



