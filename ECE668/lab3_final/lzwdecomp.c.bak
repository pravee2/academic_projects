/*
Name: Varun Praveen
CUID: C15618128
Email: pravee2@clemson.edu
Course: ECE-6680
Description:This code implements LZW decompression
*/



#include"header.h"


int main(int argc, char *argv[])
{



FILE 			*fpt_in,*fpt_out;
int 			i,j;
int 			count, iter;
int 			fileSize;			
int 			dictSize;
unsigned char 		byte;
unsigned short		code[MAXCOUNT];
unsigned short 		currcode, prevcode;
unsigned char		**dictionary;
unsigned char 		p,c;
unsigned char		*xstring,ystring,*xPlusYstring;
int 			dlength[MAXCOUNT];
int 			xlength,xPlusYlength;
int 			k,l,m;
int			elemindict;
if(argc!=3)
{
	printf("Invalid Usage!\nUsage: lzwcomp [input filename] [output filename]\n");
	exit(0);
}

fpt_in = fopen(argv[1], "rb");		

if(fpt_in == NULL)
{
	printf("Invalid file name for input file: %s \n", argv[1]);
	exit(0);
}


fileSize = 0;

// computing file size
while(j = fread(&byte,1, 1,fpt_in)!=0)
{ 
	fileSize++;
}

//fileSize--;
//fileSize--;

fseek(fpt_in,0, SEEK_SET );
printf("Filesize : %d\n", fileSize);

fpt_out = fopen(argv[2],"wb");

/****************************** INTIALIZING DICTIONARY WITH ROOTS **********************************/

dictionary = (unsigned char**)malloc(65536*sizeof(unsigned char*));

for(i=0;i<256;i++)
{
	dictionary[i] = (unsigned char*)calloc(1,sizeof(unsigned char));
	dictionary[i][0] = i;
//	printf("dictionary[%d] = %s\n", i, dictionary[i]);
	dlength[i] = 1;
	code[i] = i;
}

iter = 1;

dictSize = 256;

j = fread(&currcode,sizeof(unsigned short),1,fpt_in);
fwrite(dictionary[currcode],sizeof(unsigned char),dlength[currcode],fpt_out);

//pstring = (unsigned char*)calloc(1,1);
//*pstring = '\0';

fileSize-=j*(sizeof(unsigned short));

printf("Filesize after first write: %d\n",fileSize);

/*while(fileSize>0)*/do{
prevcode = currcode;
j = fread(&currcode,sizeof(unsigned short),1,fpt_in);
fileSize-=j*2;
printf("Filesize after first write: %d\n",fileSize);
printf("currcode : %d\n", currcode);
if(currcode <dictSize)
{
	fwrite(dictionary[currcode],sizeof(unsigned char),dlength[currcode],fpt_out);
	xstring = (unsigned char*)calloc(dlength[prevcode],sizeof(unsigned char));
	for(k=0;k<dlength[prevcode];k++)
		xstring[k] = dictionary[prevcode][k];
	ystring = dictionary[currcode][0];
	xPlusYstring = concat(xstring,ystring);
	for(k=0;xPlusYstring[k]!='\0';k++);
	xPlusYlength = k;
	k=0;		
	if(dictSize<65536)
	{
		dictionary[dictSize] = (unsigned char*)malloc(xPlusYlength*sizeof(unsigned char));
		for(l=0;l<xPlusYlength;l++)
			dictionary[dictSize][l] = xPlusYstring[l];
		l=0;
		dlength[dictSize] = xPlusYlength;
		code[dictSize] = dictSize;
		dictSize++;	
	}
	free(xstring);
	free(xPlusYstring);		
}

if(currcode>=dictSize)
{

	xstring = (unsigned char*)calloc(dlength[prevcode],sizeof(unsigned char));
	for(k=0;k<dlength[prevcode];k++)
		xstring[k] = dictionary[prevcode][k];
	ystring = dictionary[prevcode][0];
	xPlusYstring = concat(xstring,ystring);
	for(k=0;xPlusYstring[k]!='\0';k++);
	xPlusYlength = k;
	k=0;
	fwrite(xPlusYstring,sizeof(unsigned char),xPlusYlength,fpt_out);	
	if(dictSize<65536)
	{
		dictionary[dictSize] = (unsigned char*)malloc(xPlusYlength*sizeof(unsigned char));
		for(l=0;l<xPlusYlength;l++)
			dictionary[dictSize][l] = xPlusYstring[l];
		l=0;
		dlength[dictSize] = xPlusYlength;
		code[dictSize] = dictSize+1;
		dictSize++;	
	}
	free(xstring);
	free(xPlusYstring);
}
}while(fileSize>0);
//do
//{




//}while(/*!feof(fpt_in)*/fileSize>0);




printf("Dictionary Size:%d\n",dictSize);
/*for(i=dictSize-(dictSize-256)-1;i<dictSize;i++)
{
	printf("dictionary [%d] : ", i);
	for(k=0;k<dlength[i];k++)
		printf("%c\t",dictionary[i][k]);
	printf("dlength: %dend\n", dlength[i]);
}
*/

fclose(fpt_in);
fclose(fpt_out);
free(dictionary);
//free(pstring);
//free(pPlusCstring);
return 0;	

}
